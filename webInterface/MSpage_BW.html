 <!DOCTYPE html>
<html>

<head>
<title>Calculateur Valeur U avec profilé métallique</title>
<script src="https://cdn.plot.ly/plotly-2.2.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/pyodide/v0.17.0/full/pyodide.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.2/jspdf.min.js"></script>
<script src="https://unpkg.com/jspdf-autotable@3.5.15/dist/jspdf.plugin.autotable.js"></script>
<style>

input[type=button], input[type=submit], select, input[type=number]{
  padding: 5px 5px;
  margin: 1px 1px;
  cursor: pointer;
  background-color: #fff	;
  font-size:16px;
   border-radius: 4px;
}
input{width: auto;}
select{
width:170px;
 border-radius: 4px; }

#layersTable .rightalign {
	text-align:center;
}
th {
vertical-align: text-top;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
}
.up {
  transform: rotate(-135deg);
  -webkit-transform: rotate(-135deg);
}
.right {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

.left {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.down {
  transform: rotate(45deg);
  -webkit-transform: rotate(45deg);
}    
#results_table, #boundaryConditionsTable {
  border-spacing: 8px 0px;
}

body{
font-family: neue-haas-unica,sans-serif;
color: #495057;
font-size: 16px;
background-color: #eee;
margin:0px;	
}

  .container
{
    padding-left: 40px;
    padding-right: 40px;
  }
  
  .layout-header
{
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #fff;
  height: 64px;
  box-shadow: 0 1px 3px #646464;
  padding: 0 10px;
  margin: 0px;
}

.layout-header .logo, .layout-header .tool-logo
{
  height: 50px;
  max-height: 50px;
}

#languageSelect{
width:50px;
margin-right:20px;
}


</style>

</head>

<body>

<script>

function addRow(eValue = 2, lambdaValue = 0.2, cValue = "insulation",checked='') {
	var table = document.getElementById( 'layersTable' );
	var nRows = table.rows.length;
	row = table.insertRow(-1);
	//cell0 = row.insertCell(0);
	cell1 = row.insertCell(0);
	cell2 = row.insertCell(1);
	cell3 = row.insertCell(2);
	cell4 = row.insertCell(3);
	
	cell5 = row.insertCell(4);
	
	cell1.innerHTML='<input type="number" min="0" id="e'+nRows.toString()+'"size="6" value="'+eValue.toString()+'" onchange="drawAll();return null;"/>'
	cell2.innerHTML='<input type="number" min="0.010" id="t'+nRows.toString()+'" size="8" step="0.001" value="'+lambdaValue.toString()+'"/>'
	cell3.innerHTML='<select id="m'+nRows.toString()+'" onchange="changeType('+nRows.toString()+')"</select>'
	
	var select = document.getElementById('m'+nRows.toString());
    var options = getMaterials();

    for(var i = 0; i < options.length; i++) {
        var opt = options[i];
        var el = document.createElement("option");
        el.textContent = getMaterialName(opt);
        el.value = opt;
		el.setAttribute('lang_key',opt);
        select.appendChild(el);
    }
	
	
	cell4.innerHTML='<input type="checkbox" id="cb'+nRows.toString()+'" onchange="cbselected('+nRows.toString()+');" '+checked+'/>'
	cell4.classList.add("rightalign")

	let upbtn =  document.createElement("button");
	upbtn.id = "up"+nRows.toString();
	//upbtn.innerHTML = "&uarr;"; // arrow up
    //upbtn.innerHTML = "<i
    upbtn.innerHTML ='<i class="arrow up"></i>'
	upbtn.onclick = function(){upNdown(nRows,'up');}
    
	cell5.appendChild(upbtn);
	
	let downbtn =  document.createElement("button");
	downbtn.id = "down"+nRows.toString();
    downbtn.innerHTML ='<i class="arrow down"></i>'
	downbtn.onclick = function(){upNdown(nRows,'down');}
	
	cell5.appendChild(downbtn);

	/*let delbtn =  document.createElement("button");
	delbtn.id = "del"+nRows.toString();
	delbtn.innerHTML = "&#10008;"; //cross
	cell5.appendChild(delbtn);
	*/	
	select = document.getElementById( "m"+nRows.toString());
	select.value=cValue,
	drawAll();
}


function removeRow() {
	var table = document.getElementById( 'layersTable' );
	table.deleteRow(-1);
	drawAll();
}


function upNdown(index,direction)
{


	var rows = document.getElementById("layersTable").rows,
	parent = rows[index].parentNode;
	if(direction === "up")
	{
		 if(index > 1){
			parent.insertBefore(rows[index],rows[index - 1]);
			// when the row go up the index will be equal to index - 1
			switchElementsIds(index,index-1);
			index--;
		}
	 }
	 
	 if(direction === "down")
	 {
		 if(index < rows.length -1){
			parent.insertBefore(rows[index + 1],rows[index]);
			// when the row go down the index will be equal to index + 1
			switchElementsIds(index,index+1);
			index++;
			
		}
	 }
	 drawAll();
}

function switchElementsIds(rowid1,rowid2){
	
	var typeID = ["e","t","m","cb","up","down"];
	
	
	
	typeID.forEach( item => {
		
		var id1 = item+rowid1.toString();
		var id2 = item+rowid2.toString();
		
		element1 = document.getElementById(id1);
		element2 = document.getElementById(id2);

		element1.id = id2;
		element2.id = id1;
		
		if (item=='m'){
			element1.onchange = function() {changeType(rowid2);}
			element2.onchange = function() {changeType(rowid1);}
		}
		if (item=="cb"){
			element1.onchange = function() {cbselected(rowid2);}
			element2.onchange = function() {cbselected(rowid1);}
		}
		if (item=='up'){
			element1.onclick = function() { upNdown(rowid2,'up')}
			element2.onclick = function() {upNdown(rowid1,'up');}
		}
		if (item=='down'){
			element1.onclick = function() { upNdown(rowid2,'down')}
			element2.onclick = function() {upNdown(rowid1,'down');}
		}
	});
	
	
}



function cbselected(checkboxid) {
	var table = document.getElementById( 'layersTable' );
	var nRows = table.rows.length;
	
	for (let i=1; i<nRows; i+=1){
		var cb = document.getElementById('cb'+i.toString());
		
		if (checkboxid != i){
			cb.checked = false;
		}
		else{
			cb.checked = true; //this way, it remains true if try to unclick --> always one remains clicked
		}
	}

}


function getBridgedLayer(){

	var table = document.getElementById( 'layersTable' );
	var nRows = table.rows.length;
	
	for (let i=1; i<nRows; i+=1){
		var cb = document.getElementById('cb'+i.toString());
		
		if (cb.checked){
			return i;
		}
	}

}


// material functions

function getMaterials(){

    return ['gypsum','wood','insulation','briques','stone','concreteBlocs','air_nv','air_pv']
    
}

function getColors(){

	return {'gypsum':'White',
			'wood':'Brown',
			'insulation':'Yellow',
			'briques':'Indianred', //Coral is also good
			'air_pv':'lightblue',
			'air_nv':'lightblue',	
			'stone':'grey',
			'concreteBlocs':'grey'
			};
}

function getDefaultMaterialConductivity(material){

	var dict = {'gypsum': 0.2,
				'insulation':0.035,
				'briques':1.5,
				'wood':0.13,
				'stone':2.5,
				'concreteBlocs':1.5
				};
			
	return dict[material];

}

function getCurrentLanguage() {
  const languageSelect = document.getElementById('languageSelect');
  return languageSelect.value; // This will return the value of the selected option, e.g., 'en', 'fr', 'es', etc.
}

function getMaterialName(material){

	lang=getCurrentLanguage()
	
	
	
	var dict = {'gypsum':{
					'en':'Plaster',
					'fr':'Platre',
					'nl':'Pleister'
					},
				'insulation':{
					'en':'Insulation',
					'fr':'Isolant',
					'nl':'Insulatie'
					},
				'briques':{
					'en':'Bricks',
					'fr':'Briques',
					'nl':'Pleister'
					},
				'wood':{
					'en':'Wood',
					'fr':'Bois',
					'nl':'Hout'
					},
				'air_nv':{
					'en':'Air (not ventilated)',
					'fr':'Lame d\'air NV (R=0.18)',
					'nl':'Lucht (zonder circulatie)'
					},
				'air_pv':{
					'en':'Air (ventilated)',
					'fr':'Lame d\'air PV (R=0.09)',
					'nl':'Lucht (met circulatie)'
					},
				'stone':{
					'en':'Stone',
					'fr':'Pierre',
					'nl':'Pierre'
					},
				'concreteBlocs':{
					'en':'Concrete',
					'fr':'Blocs béton',
					'nl':'Betonblok'
					}
				};
			
	return translations[material][lang];

	//return dict[material][lang];

}

function isAirLayer(material){

	var airLayersTypes=['air_nv','air_pv'];

	if (airLayersTypes.includes(material))
	{
		return true;
	}
	else{
		return false;
	}
}

function hasMoreThanOneAirLayer(){

	layers=getLayersInfo()
	
	var nAirLayers = 0;
	
	layers.forEach(item =>{
		material = item['material'];
		
		if (isAirLayer(material)){
			nAirLayers += 1;
		}	
	});
	
	if (nAirLayers > 1){
		return true
		}
	else{
		return false
		}
}




function getAirLayerResistance(material){

	var dict = {'air_nv':0.18,
				'air_pv':0.09
				};
				
	return dict[material]
}



function changeType(layerid){

	if (hasMoreThanOneAirLayer()){
		alert("Le calculateur ne peut traiter qu'une seule lame d'air. Assurez vous d'avoir une seule lame d'air avant de lancer le calcul, sinon aucun résultat ne sera retourné");
	}

	var layers = getLayersInfo();
	var counter=1;
	layers.forEach(item => {
		colorElement = document.getElementById('m'+counter.toString());
		lambdaElement = document.getElementById('t'+counter.toString());
	
		material = item['material']
		
		if (layerid == counter && isAirLayer(material) ){
			//colorElement.value = 'air';
			lambdaElement.value = NaN;
			//colorElement.disabled = true;
			lambdaElement.disabled = true;
			
			}
		else {
			if (layerid != counter && isAirLayer(material) ){
				//colorElement.value = 'insulation'
				//colorElement.value = 'insulation'
				//colorElement.disabled = false;
				lambdaElement.disabled = false;
				//lambdaElement.value = '0.035';
			
			}
			if (layerid == counter && !isAirLayer(material)){

			   	//colorElement.disabled = false;
				lambdaElement.disabled = false;
				//colorElement.value = 'insulation';
				lambdaElement.value = getDefaultMaterialConductivity(item['material']);
			
			}
		}
		
		
		counter+=1
	}
	);
	drawAll()
}


function getLayersInfo(){
	var table = document.getElementById( 'layersTable' );
	var nRows = table.rows.length;

	var layers = [];

	for (let i=1; i<nRows; i+=1){
		//var type = document.getElementById('type'+i.toString()).value
		var thickness = document.getElementById('e'+i.toString()).value
		var kappa     = document.getElementById('t'+i.toString()).value
		var material  = document.getElementById('m'+i.toString()).value

		//console.log(thickness,kappa,material)
		
		var layerJson = {};
		//layerJson['type']= type;
		layerJson['thickness']=thickness;
		layerJson['lambda']=kappa;
		layerJson['material']=material;
		
		layers.push(layerJson);

	}
	return layers;
}

function getCumThickness(){
	var layers = getLayersInfo();
	
	var cumT = 0;
	
	layers.forEach(item => {cumT += parseFloat(item['thickness']) } );

	return cumT
}

function getTheoriticalR(withRsiRse=false){
	var layers = getLayersInfo();
	var cumR = 0;
	
	layers.forEach(item => {
	if (isAirLayer(item['material'])){
		cumR += getAirLayerResistance(item['material']);
		}
	else{
		cumR += parseFloat(item['thickness'])/100/parseFloat(item['lambda']); 
		}
	} 
	);

	if (withRsiRse){
		bcs= getBoundaryConditions();
		cumR+= 1/bcs['hi']+1/bcs['he'];
	}
	return cumR.toFixed(2);
}


function getMetalData(){
	//var table = document.getElementById( 'metalTable' );

	var data = {'shape':document.getElementById('MSshape').value,
				'e':parseFloat(document.getElementById('MSe').value),
				'h':parseFloat(document.getElementById('MSh').value),
				'w':parseFloat(document.getElementById('MSw').value),
				'p':parseFloat(document.getElementById('MSp').value),
				'EA':parseFloat(document.getElementById('MSentreAxe').value)
				};
	//console.log(data);
	
	return data;		
}

function getBoundaryConditions(){

	var data = {'hi':parseFloat(document.getElementById('hi').value),
				'he':parseFloat(document.getElementById('he').value),
				'Te':parseFloat(document.getElementById('Te').value),
				'Ti':parseFloat(document.getElementById('Ti').value),
				};
				
	console.log(data);
	return data;
}



function drawAll(){

	entreAxe = getMetalData()['EA'];
	layerShapes = getLayersShape(entreAxe);
	
	cumThickness=getCumThickness();
	metalData = getMetalDrawing();

	var layout = {
		margin: {
		l: 30,
		r: 10,
		b: 30,
		t: 10,
	  },
		paper_bgcolor:"Aliceblue",
		plot_bgcolor:"Aliceblue",

		xaxis: {
			range: [-1,cumThickness],
			showgrid: false,
			zeroline: false,
			showline: false,
			autotick: true,
			tickmode: "array",
			tickvals: [0,cumThickness],
		  },
		yaxis: {
			range: [-1,entreAxe],
			scaleanchor: "x",
			scaleratio: 1,
			showgrid: false,
			zeroline: true,
			showline: false,
			autotick: true,
			tickmode: "array",
			tickvals: [0,entreAxe],
		},
		width: 300,
		height: 800,
		shapes: layerShapes
	};

	var metalTrace = {
		x: metalData[0],
		y: metalData[1],
		mode: 'lines',
		line: {
			color: 'Red',
			width: 4
		}
	}
	
	geometryPlot = document.getElementById('geometryPlot');
	Plotly.newPlot(geometryPlot, [metalTrace], layout );
}

function getLayersShape(entreAxe=60){

	var layers = getLayersInfo();
	var rectangleShapes = []

	var cumThickness = 0
	var endThickness = 0

	colors = getColors();

	layers.forEach(item => {

		endThickness = cumThickness+parseInt(item['thickness'],10)

		//Filled Rectangle
		var rect = {
			type: 'rect',
			x0: cumThickness,
			y0: 0,
			x1: endThickness,
			y1: entreAxe,
			line: {
				color: 'rgba(0, 0,0, 1)',
				width: 2
			},
			fillcolor: colors[item['material']],
			layer: 'below'
		};
		rectangleShapes.push(rect);
		
		if (item['material']==='briques')
		{
			brickShapes = getBrickShapes(cumThickness,item['thickness'],entreAxe)
			rectangleShapes = rectangleShapes.concat(brickShapes)
		}
		if (item['material']==='stone')
		{
			patterns = getStoneShapes(cumThickness,item['thickness'],entreAxe)
			rectangleShapes = rectangleShapes.concat(patterns)
		}
		if (item['material']==='concreteBlocs')
		{
			patterns = getBlockShape(cumThickness,item['thickness'],entreAxe)
			rectangleShapes = rectangleShapes.concat(patterns)
		}

		cumThickness = endThickness;
		
	}
	);

	return rectangleShapes;

}

function getBlockShape(startX,width,height,refHeight=20){

    bricksShapes = []

	var nBrickRows = Math.floor(height/refHeight);
	var brickHeight = height/nBrickRows
	var brickWidth =  Math.floor(width) //convert to int
	
	
	for (let i=0; i<nBrickRows; i+=1){
		
		var rect1 = {
			type: 'rect',
			x0: startX,
			y0: i*brickHeight,
			x1: startX+brickWidth,
			y1: (i+1)*brickHeight,
			line: {
				color: 'rgba(0,0,1, 1)',
				width: 2
			},
			layer: 'above'
		};
		
		bricksShapes.push(rect1);
		
	}
	console.log(bricksShapes)
	return bricksShapes;
}


function getStoneShapes(startX,width,height){

	return getBrickShapes(startX,width,height,14,'beige','4')
}

function getBrickShapes(startX,width,height,refHeight=7,color='black',w=2){

	bricksShapes = []

	var nBrickRows = Math.floor(height/refHeight);
	var brickHeight = height/nBrickRows
	var brickWidth =  bricklen = width/1.5
	
	for (let i=0; i<nBrickRows; i+=1){

		rowStart = startX
		
		start1=startX
		if (i%2==0){
			width1=brickWidth
			width2=brickWidth/2
			}
		else{
			width1=brickWidth/2
			width2=brickWidth
		}
		start2=start1+width1

		
		var rect1 = {
			type: 'rect',
			x0: start1,
			y0: i*brickHeight,
			x1: start1+width1,
			y1: (i+1)*brickHeight,
			line: {
				color: color,
				width: w
			},
			layer: 'below'
		};
		
		var rect2 = {
			type: 'rect',
			x0: start2,
			y0: i*brickHeight,
			x1: start2+width2,
			y1: (i+1)*brickHeight,
			line: {
				color: color,
				width: w
			},
			layer: 'below'
		};
		
		bricksShapes.push(rect1);
		bricksShapes.push(rect2);
		
	}
	console.log(bricksShapes);
	return bricksShapes;
	
}
	


function getMetalDrawing(){

	metalData = getMetalData();

	if (metalData['shape'] == 'C-shape'){

		ystart = metalData['EA']/2 - metalData['h']/2;
		x1 = metalData['p'];
		y1 = ystart;
		x2 = x1;
		y2 = y1+metalData['h'];
		x3 = x1+metalData['w'];
		y3=y2
		y4=y1
		x4=x3
	}
	if (metalData['shape'] == 'U-shape'){

		ystart = metalData['EA']/2  + metalData['w']/2;

		x1 = metalData['p'] + metalData['h'];
		y1 = ystart;

		x2 = x1 - metalData['h'];
		y2 = y1;

		x3 = x2;
		y3 = y2 - metalData['w']

		x4=x1
		y4=y3
	}
	//console.log(x1)
	
	x=[x1,x2,x3,x4];
	y=[y1,y2,y3,y4];
	
	return  [x,y]
}

async function loadMSCalculator(){
	pyodide.runPython(await (await fetch('https://raw.githubusercontent.com/sebbypy/MScalculator/main/python/MSCalculator.py')).text());
}


async function loadAllPython(){

	await loadPyodide({
          indexURL : "https://cdn.jsdelivr.net/pyodide/v0.17.0/full/"
        });

	await pyodide.loadPackage('numpy');
	await loadMSCalculator();

}

async function computeAndPlot(){

	
	if (hasMoreThanOneAirLayer()){
		alert("Le calculateur ne peut traiter qu'une seule lame d'air. Modifiez la configuration pour pouvoir lancer le calcul");
		return
	}



	var dataToPlot = await compute();
	Xvalues = dataToPlot[0];
	Yvalues = dataToPlot[1];
	Zvalues = dataToPlot[2];
	Rvalues = dataToPlot[3];
	
	
	showRvalues(Rvalues);
	plotTemperatureField(Xvalues,Yvalues,Zvalues);

}

function showRvalues(Rvalues){

	document.getElementById("R1").innerHTML = '('+Rvalues.get('R1').toFixed(2)+')';
	document.getElementById("R2").innerHTML = '('+Rvalues.get('R2').toFixed(2)+')';
	document.getElementById("Rsup2").innerHTML = '('+(Rvalues.get('R1')-Rvalues.get('R2')).toFixed(2)+')';
	document.getElementById("Uvalue2").innerHTML = '('+(1/Rvalues.get('R1')).toFixed(3)+')';

	document.getElementById("R3").innerHTML = Rvalues.get('R3').toFixed(2);
	document.getElementById("R4").innerHTML = Rvalues.get('R4').toFixed(2);
	document.getElementById("Rsup").innerHTML = (Rvalues.get('R3')-Rvalues.get('R4')).toFixed(2);
	document.getElementById("Uvalue").innerHTML = (1/Rvalues.get('R3')).toFixed(3);
}


async function compute(){

	layers = getLayersInfo();
	metal = getMetalData();
	bcs = getBoundaryConditions();

	//pas parameters as string
	eIsol = [] 
	kIsol = []
	hMetal = metal['h']
	pMetal = metal['p']
	wMetal = metal['w']
	eMetal = metal['e']
	entreAxe = metal['EA']
	shape = metal['shape']

	bcs = getBoundaryConditions();

	layers.forEach(item => { eIsol.push(parseFloat(item['thickness'])) })
	layers.forEach(item => { kIsol.push(parseFloat(item['lambda'])) })


	airLayerResistance=0.18
	layers.forEach(item => { 
		if (isAirLayer(item['material']))
		{
			airLayerResistance = getAirLayerResistance(item['material']);
		}
	});
		
	await pyodide.runPython(`

import js
eIsol = [x/100 for x in js.eIsol.to_py()]
kIsol = js.kIsol.to_py()
eMetal = js.eMetal/1000 #mm in js, m in py
pMetal = js.pMetal/100  #cm to mm
hMetal = js.hMetal/100  
wMetal = js.wMetal/100
shape = js.shape;
entreAxe = js.entreAxe/100

ResistanceAirLayer = js.airLayerResistance

bcs = js.bcs.to_py()

solver = MsSolver(layersThickness = eIsol,
					layersConductivity = kIsol.copy() , 
					pMetal=pMetal , 
					wMetal = wMetal, 
					hMetal = hMetal, 
					entreAxe = entreAxe,
					kMetal = 50, 
					eMetal = eMetal, 
					hi=bcs['hi'],
					he=bcs['he'],
					Ti=bcs['Ti'],
					Te=bcs['Te'],                         
					MStype=shape,
					ResistanceAirLayer=ResistanceAirLayer
					)
					
solver.solve()
TemperatureField = solver.T
x,y = solver.getFlattenedXandY()
Rvalues = solver.computeUandRValues()

							
x=x*100 #back to cm
y=y*100 #back to cm
`)

	var X=pyodide.globals.get('x').toJs();
	var Y=pyodide.globals.get('y').toJs();
	var Z=pyodide.globals.get('TemperatureField').toJs();
	var Rvals=pyodide.globals.get('Rvalues').toJs();

	//console.log(Rvals);

	return [X,Y,Z,Rvals]
}


async function plotTemperatureField(Xvalues,Yvalues,Zvalues){

		metalData = getMetalData();
		var entreAxe = metalData['EA'];
		var cumThickness = getCumThickness();

		var layout = {
		margin: {
		l: 30,
		r: 10,
		b: 30,
		t: 10,
		},
		paper_bgcolor:"Aliceblue",
		plot_bgcolor:"Aliceblue",
		xaxis: {
			range: [-1,cumThickness],
			showgrid: false,
			zeroline: false,
			showline: false,
			autotick: true,
			tickmode: "array",
			tickvals: [0,cumThickness],
		  },
		yaxis: {
			range: [-1,entreAxe],
			scaleanchor: "x",
			scaleratio: 1,
			showgrid: false,
			zeroline: true,
			showline: false,
			autotick: true,
			tickmode: "array",
			tickvals: [0,entreAxe],
		},
		width: 400,
		height: 800,
		}

	metalData = getMetalDrawing();

	var metalTrace = {
		x: metalData[0],
		y: metalData[1],
		mode: 'lines',
		line: {
			color: 'Black',
			width: 2
		}
	}

	var contour = {
		x: Xvalues,
		y: Yvalues,
		z: Zvalues,
		type: 'contour',
		colorbar:{
			thickness: 50,
			thicknessmode: 'pixels'
			}
		}
		
	temperaturePlot = document.getElementById('temperaturePlot');
	Plotly.newPlot(temperaturePlot, [contour,metalTrace], layout);

}

</script>

<header class="layout-header">

<div><span class="logo-full">
<img class="logo" src="https://images.prismic.io/bbri/0f1c879e-8d5e-4201-a0d2-2dbf3bd95d33_Buildwise_Horizontaal_noir_marge.png?auto=compress,format&amp;rect=0,0,2000,500&amp;w=740&amp;h=185" alt="BBRI logo"></span>
</div>
<img class="tool-logo" src="https://images.prismic.io/bbri/6cb70e31-2f6b-4657-80b5-a512d17a71c1_heatload_logo.jpg?auto=compress,format" alt="Tool logo">

<div class="right-header">
<select id="languageSelect">
  <option value="en">EN</option>
  <option value="fr">FR</option>
  <option value="nl">NL</option>
</select>

</div>
</header>

<div class="container">

<h1 lang_key="title">Calculateur Valeur U avec profilé métallique</h1>

<div style = "height:800px; width:750px; float:right;">
	<div id="geometryPlot" style="height:800px; float:left; border:1px solid black;"></div>
	<div id="temperaturePlot" style="height:800px; float:left; border:1px solid black;"></div>
</div>

<div id="layers" style="width: 50%">
<h2 lang_key="insert_layers">Insérer les couches</h2>

<table id="layersTable">
  <tr>
    <th lang_key="thickness_cm">Epaisseur [cm]</th>
    <th>&#955; [W/mK]</th>
	<th lang_key="material_type">Type de matériau</th>
	<th lang_key="associate_bridge_to_this_layer">Associer le pont thermique<br> à cette couche ?</th>
  </tr>
</table> 
<input type="submit" lang_key="add_layer" value="Ajouter une couche" onclick="addRow();return null;">
<input type="submit" lang_key="delete_layer" value="Supprimer une couche" onclick="removeRow();return null;">

</div>

<div id="profile">
<h2 lang_key="insert_profile">Insérer les caractéristiques du profilé</h2>

<table id="metalTable" textalign="left">
  <tr>
    <th lang_key="orientation" style="text-align:left">Orientation</th>
	<td><select style="width:70px" id='MSshape' onchange="drawAll();return null;">
			<option value='C-shape'>0°</option>
			<option value='U-shape'>90°</option>
		</select>
	</td>
  </tr>
  <tr>
    <th style="text-align:left" lang_key="profile_width_cm">Largeur profilé [cm]</th>
	<td><input type="number" min="1" value="5" step="1" id="MSw" onchange="drawAll();return null;" size="7">
  </tr>
    <tr>
    <th style="text-align:left" lang_key="profile_height_cm">Hauteur profilé [cm]</th>
	<td><input type="number" min="1" value="5" step="1" id="MSh" onchange="drawAll();return null;" size="7">
  </tr>
  <tr>
    <th style="text-align:left" lang_key="profile_thickness_mm">Epaisseur du profilé [mm]</th>
	<td><input type="number" min="0.1" value="0.6" step="0.1" id="MSe" size="7">
  </tr>
  <tr>
    <th style="text-align:left" lang_key="profile_distance_from_inside_cm" >Position (depuis l'intérieur) [cm]</th>
	<td><input type="number" min="0" value="2" step="1" id="MSp" onchange="drawAll();return null;" size="7">
  </tr>
  <tr>
    <th style="text-align:left" lang_key="center_distance_cm" >Entre-axe [cm]</th>
	<td><input type="number" min="10" value="60" step="5" id="MSentreAxe" onchange="drawAll();return null;" size="7">
  </tr>
</table> 
</div>


<div id="profile">
<h2 lang_key="boundary_conditions">Conditions aux limites</h2>

<table id="boundaryConditionsTable" textalign="left">
  <tr>
    <th style="text-align:left">hi [W/m²K]</th>
	<td><input type="number" min="1" value="10" step="1" id="hi" size="7" onchange="updateRsi()"></td>
    <td style="text-align:left">(Rsi =</td>
    <td id='RSIvalue'>0.10)</td>
 </tr>
  <tr>
    <th style="text-align:left">he [W/m²K]</th>
	<td><input type="number" min="1" value="10" step="1" id="he" size="7" onchange="updateRse()"></td>
    <td style="text-align:left">(Rse =</td>
    <td id='RSEvalue'>0.10)</td>
  </tr>
  <tr>
    <th style="text-align:left">Ti [°C]</th>
	<td><input type="number" value="20" step="1" id="Ti" size="7"></td>
    <td></td>
  </tr>
  <tr>
    <th style="text-align:left">Te [°C]</th>
	<td><input type="number" value="0" step="1" id="Te"	size="7"></td>
    <td></td>
  </tr>
</table> 
</div>

<script>
function updateRsi(){
	hiElement = document.getElementById("hi")
	hiValue = hiElement.value
	RsiValue = 1/hiValue
	
	RSI = document.getElementById("RSIvalue")
	RSI.innerHTML=RsiValue.toFixed(2).toString()+')'
	
}
function updateRse(){
	heElement = document.getElementById("he")
	heValue = heElement.value
	RseValue = 1/heValue
	
	RSE = document.getElementById("RSEvalue")
	RSE.innerHTML=RseValue.toFixed(2).toString()+')'
	
}
</script>

<div id="results_div">
<h2 lang_key="results" >Résultats</h2>
<table id="results_table" textalign="left">
  <tr>
    <th></th>
	<th></td>
	<th lang_key="with_profile">Avec profilé</td>
	<th lang_key="without_profile"> (valeur théorique sans profilé)</td>
  </tr>
  <tr>
    <th style="text-align:left">R<sub>paroi</sub></th>
	<th>m²K/W</th>
	<td style="text-align:center" id="R4"></td>
	<td style="text-align:center" id="R2"></td>
  </tr>
  <tr>
    <th style="text-align:left">R<sub>si</sub> + R<sub>se</sub></th>
	<th>m²K/W</th>
	<td style="text-align:center" id="Rsup"></td>
	<td style="text-align:center" id="Rsup2"></td>
  </tr>
  <tr>
    <th style="text-align:left">R<sub>tot</sub></th>
	<th>m²K/W</th>
	<td style="text-align:center" id="R3"></td>
	<td style="text-align:center" id="R1"></td>
  </tr>
  <tr>
    <th style="text-align:left">U<sub>tot</sub></th>
	<th>W/m²K</th>
	<td style="text-align:center" id="Uvalue"></td>
	<td style="text-align:center" id="Uvalue2"></td>
  </tr>
</table>

<input type="submit" lang_key="calculate_button" value="Calculer" onclick="computeAndPlot();return null;">
</div>

<script>

const getBase64FromUrl = async (url) => {
  const data = await fetch(url);
  const blob = await data.blob();
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.readAsDataURL(blob); 
    reader.onloadend = () => {
      const base64data = reader.result;   
      resolve(base64data);
    }
  });
}

function getDateString(){
	var today = new Date();
	var dd = String(today.getDate()).padStart(2, '0');
	var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!
	var yyyy = today.getFullYear();
	today = dd + '/' + mm+ '/' + yyyy;

	return today;
}

async function addPlotlyImage(doc,plotlyPlot,xpos,ypos) {
  
	geoplot = document.getElementById(plotlyPlot);
	await Plotly.toImage(plotlyPlot, { format: 'jpeg', width: 1350, height: 2700 })
		.then(
             function(url)
         {
			doc.addImage(url,"JPEG",xpos,ypos,75,150);
	    }
         );
  
}


async function genPDF(){

	lang = getCurrentLanguage()
    
	// Default export is a4 paper, portrait, using millimeters for units
	const doc = new jsPDF('a4');

	doc.setFontSize(15);
    

	
	var base64 = await getBase64FromUrl('https://images.prismic.io/bbri/0f1c879e-8d5e-4201-a0d2-2dbf3bd95d33_Buildwise_Horizontaal_noir_marge.png?auto=compress')
	//aspect ratio: 4:1
	
	doc.addImage(base64,"JPEG",20,10,100,25)
	

	latestY = 35

	doc.text(translations['pdf_title'][lang], 20, latestY+20);

	doc.setFontSize(12);

	layers = getLayersInfo();
	bcs = getBoundaryConditions();


	RLayers = parseFloat(document.getElementById('R4').innerHTML).toFixed(2);
	Rtot = parseFloat(document.getElementById('R3').innerHTML).toFixed(2);
    deltaR = parseFloat(Rtot)-parseFloat(getTheoriticalR(true));

	bridgedLayer = getBridgedLayer();


	layers.forEach( (x,index) => {
	  if (!isAirLayer(x['material'])){
			x['resistance']=(x['thickness']/100/x['lambda']).toFixed(2); 
		}
		else{
			x['resistance']=getAirLayerResistance(x['material']).toFixed(2);
			}
		x['index']=index+1;

	});

	layers.forEach( (x,index) => {
		
		if (!isAirLayer(x['material'])){
	  
			x['resistance2']=(x['thickness']/100/x['lambda']).toFixed(2); 
			}
		else{
			x['resistance2']=getAirLayerResistance(x['material']).toFixed(2);
			}
	
		x['index']=index+1;

		if (x['index'] == bridgedLayer){
			
			x['resistance2'] = (parseFloat(x['resistance2']) + deltaR).toFixed(2);
		}
		x['materialName']=getMaterialName(x['material']);
		});
	
	
	layers.push({'thickness':getCumThickness(),'resistance':getTheoriticalR(),'resistance2':RLayers,'materialName':'Total paroi'});
	
	Rsup = 1/bcs['hi']+1/bcs['he'];
	
	//layers.push({'thickness':'','resistance':Rsup,'resistance2':Rsup,'materialName':'Rsi+Rse'});
	//layers.push({'thickness':'','resistance':getTheoriticalR(true),'resistance2':Rtot,'materialName':'Total(avec Rsi et Rse)'});

	
	headers = [ { header: translations['material_type'][lang], dataKey:'materialName'},
	            { header: translations['thickness_cm'][lang], dataKey: 'thickness' },
				{ header: translations['pdf_lambda'][lang], dataKey: 'lambda' },
				{ header: translations['pdf_R_bridged'][lang], dataKey: 'resistance2' },
				{ header: translations['pdf_R_unbridged'][lang], dataKey: 'resistance' }
				]

	// Couches
	doc.text(translations['pdf_layers_title'][lang],20,latestY+30)
	doc.setFontSize(8);
	doc.text(translations['pdf_layers_grey_line'][lang],20,latestY+35)
	doc.setFontSize(12);

	BWfillColor = [0,191,182];

	doc.autoTable( {startY: latestY+40,
					margin: {top:0,left:20},
					body:layers,
					columns:headers,
					styles: {
						halign: 'center',
						cellWidth: 30
					},
					theme: 'grid',
					headStyles:{
						fillColor: BWfillColor
					},
					columnStyles:{
					 0: {cellWidth:40},
					 2: {cellWidth:35},
					 3: {cellWidth:35},
					 4: {cellWidth:35},
					},
					didParseCell: function (data) {
					  if (data.row.index === bridgedLayer-1) {
						data.cell.styles.fillColor = [220, 220, 220]
					  }
					}
					});

	let previousTableY = doc.previousAutoTable.finalY; 

	headers = [ { header: '', dataKey:'materialName'},
				{ header: translations['pdf_withThermalBridge'][lang], dataKey: 'resistance2' },
				{ header: translations['pdf_withoutThermalBridge'][lang], dataKey: 'resistance' }
				]


	summary=[]
	summary.push({'resistance':getTheoriticalR(false),'resistance2':RLayers,'materialName':translations['pdf_r_wall'][lang]+' [m²K/W]'});
	summary.push({'resistance':Rsup,'resistance2':Rsup,'materialName':'Rsi+Rse [m²K/W]'});
	summary.push({'resistance':getTheoriticalR(true),'resistance2':Rtot,'materialName':translations['pdf_r_total'][lang]+' [m²K/W]'});
	summary.push({'resistance':(1/getTheoriticalR(true)).toFixed(3),'resistance2':(1/Rtot).toFixed(3),'materialName':'U [W/m²K]'});


	doc.text(translations['pdf_total_u_and_r'][lang],20,previousTableY+10)
	doc.autoTable( {startY: previousTableY+15,
					margin: {top:0,left:20},
					body:summary,
					columns:headers,
					styles: {
						halign: 'center',
						cellWidth: 30
					},
					theme: 'grid',
					headStyles:{
						fillColor: BWfillColor
					},
					columnStyles:{
					 0: {cellWidth:40},
					 2: {cellWidth:35},
					 3: {cellWidth:35},
					},
					});


	previousTableY = doc.previousAutoTable.finalY;

	// Profile metallique
	metalData = getMetalData();
    
    if (metalData['shape'] == 'C-shape'){
        metalData['shape']='0°'
    }
    if (metalData['shape'] == 'U-shape'){
        metalData['shape']='90°'
    }
    
	headers = [ {header: translations['profile_distance_from_inside_cm'][lang], dataKey:'p'},
	            {header: translations['profile_thickness_mm'][lang], dataKey: 'e' },
				{ header: translations['profile_width_cm'][lang], dataKey: 'w' },
				{ header: translations['profile_height_cm'][lang], dataKey: 'h' },
				{ header: translations['orientation'][lang], dataKey: 'shape' },
				]

	doc.text(translations['pdf_metal_profile_characteristics'][lang],20,previousTableY+10)
	doc.autoTable({	startY: previousTableY+15,
					margin: {top:0,left:20},
					body: [metalData],
					columns:headers,
					styles: {
						halign: 'center',
						cellWidth: 30
					},
					theme: 'grid',
					headStyles:{
						fillColor: BWfillColor
					},
					columnStyles:{
					 0: {cellWidth:45}
					}
	
					});


	bcs = getBoundaryConditions();
	headers = [ {header: 'hi [W/m²K]', dataKey:'hi'},
	            {header: 'he [W/m²K]', dataKey: 'he' },
				{ header: 'Ti [°C]', dataKey: 'Ti' },
				{ header: 'Te [°C]', dataKey: 'Te' },
				]

	previousTableY = doc.previousAutoTable.finalY; 
	doc.text(translations['boundary_conditions'][lang],20,previousTableY+10)
	doc.autoTable({	startY: previousTableY+15,
					margin: {top:0,left:20},
					body: [bcs],
					columns:headers,
					styles: {
						halign: 'center',
						cellWidth: 30
					},
					theme: 'grid',
					headStyles:{
						fillColor: BWfillColor
						},
					});

	
	previousTableY = doc.previousAutoTable.finalY; 

	doc.setFontSize(8);
	doc.text(translations['pdf_generated_on'][lang]+' '+getDateString(),150,290)

	doc.addPage()

	doc.addImage(base64,"JPEG",20,10,100,25)
	latestY = 25

	doc.setFontSize(15);

	doc.text(translations['pdf_title'][lang], 20, latestY+20);

	doc.setFontSize(12);
	doc.text(translations['pdf_drawing_and_temperature_field'][lang],20,latestY+30);

	await addPlotlyImage(doc,'geometryPlot',20,70);
	await addPlotlyImage(doc,'temperaturePlot',100,70);


	doc.setFontSize(8);
	doc.text(translations['pdf_generated_on'][lang]+' '+getDateString(),150,290)


	window.open(URL.createObjectURL(doc.output("blob")))
}
</script>

<script>

const translations = {
  "title": {
    "en": "U-value calculator with metal profiles",
    "fr": "Calculateur de valeurs U avec profilés métalliques",
    "nl": "U-waarde calculator met metal profielen"
  },
  "insert_layers":  {
    "en": "Insert all layers",
    "fr": "Insérer les couches",
    "nl": "Voer in de layers"
  },
  "thickness_cm":{
    "en": "Thickness [cm]",
    "fr": "Epaisseur [cm]",
    "nl": "Dikte [cm]"
  },
   "insert_profile":  {
    "en": "Metal profile characteristics",
    "fr": "Caractéristiques du profilé",
    "nl": "Metalprofiel karakteristieken"
  },
  "orientation":{
	"en":"Orientation",
	"fr":"Orientation",
	"nl":"Orientatie"
	},
   "profile_width_cm":{
    "en": "Profile width [cm]",
    "fr": "Largeur du profilé [cm]",
    "nl": "Profiel breedte [cm]"
  },
   "boundary_conditions":{
    "en": "Boundary conditions",
    "fr": "Conditions aux limites",
    "nl": "Randvoorwaarden"
  },
  "profile_height_cm":{
    "en": "Profile height [cm]",
    "fr": "Hauteur du profilé [cm]",
    "nl": "Profiel hoogte [cm]"
  },
  "profile_thickness_mm":{
    "en": "Profile thickness [mm]",
    "fr": "Epaisseur du profilé [mm]",
    "nl": "Profiel dikte [mm]"
  },
  "profile_distance_from_inside_cm":{
    "en": "Profile position (distance from inside) [cm]",
    "fr": "Position du profilé (distance depuis l'intérieur) [cm]",
    "nl": "Profiel locatie (afstand vanaf binnenkant) [cm]"
  },
  "center_distance_cm":{
    "en": "Center distance [cm]",
    "fr": "Entre-axe [cm]",
    "nl": "Midden afstand [cm]"
  },
  "results":{
    "en": "Results",
    "fr": "Résultats",
    "nl": "Resultaten"
  },
  "material_type":{
    "en": "Material type",
    "fr": "Type de matériau",
    "nl": "Materiaaltype"
  },
  "associate_bridge_to_this_layer":{
    "en": "Apply thermal bridge to this layer",
    "fr": "Associer le pont thermique\n à cette couche",
    "nl": "Koudebrug aan dit leeg toepassen"
  },
  "with_profile":{
    "en": "With profile",
	"fr": "Avec profil",
	"nl": "Met profiel"
	},
   "without_profile":{
    "en": "(theoritical without profile)",
	"fr": "(theorique sans profil)",
	"nl": "(thoretische zonder profiel)"
	},
	"calculate_button":{
    "en": "Calculate",
	"fr": "Calculer",
	"nl": "Berekenen"
	},
	"generate_pdf":{
    "en": "Generate PDF report",
	"fr": "Générer rapport PDF",
	"nl": "PDF"
	},
	"add_layer":{
    "en": "Add layer",
	"fr": "Ajouter une couche",
	"nl": "Leeg toevoegen"
	},
	"delete_layer":{
    "en": "Delete layer",
	"fr": "Supprimer une couche",
	"nl": "Leeg verwijderen"
	},
	'gypsum':{
		'en':'Plaster',
		'fr':'Platre',
		'nl':'Pleister'
		},
	'insulation':{
		'en':'Insulation',
		'fr':'Isolant',
		'nl':'Insulatie'
		},
	'briques':{
		'en':'Bricks',
		'fr':'Briques',
		'nl':'Pleister'
		},
	'wood':{
		'en':'Wood',
		'fr':'Bois',
		'nl':'Hout'
		},
	'air_nv':{
		'en':'Air (not ventilated)',
		'fr':'Lame d\'air NV (R=0.18)',
		'nl':'Lucht (zonder circulatie)'
		},
	'air_pv':{
		'en':'Air (ventilated)',
		'fr':'Lame d\'air PV (R=0.09)',
		'nl':'Lucht (met circulatie)'
		},
	'stone':{
		'en':'Stone',
		'fr':'Pierre',
		'nl':'Pierre'
		},
	'concreteBlocs':{
		'en':'Concrete',
		'fr':'Blocs béton',
		'nl':'Betonblok'
		},
	'pdf_title':{
		'en':'U calculator',
		'fr':'Calculateur U',
		'nl':'U rekenmachine'
		},
	'pdf_layers_title':{
		'en':'Descrition of the layers (inside to outside)',
		'fr':"Description des couches (de l'intérieur vers l'extérieur)",
		'nl':"Bescrhrijving van legen (van binnen naar buiten)"
		},
	'pdf_layers_grey_line':{
		'en':'The grey line is the one to which the thermal bridge has been applied',
		'fr':"La ligne grisée est celle à laquelle le pont thermique a été appliqué",
		'nl':"De grijze lijn is digene waarover de koudebrug toegepast werd"
	},
	'pdf_lambda':{
		'en':'Thermal conductivity [W/mK]',
		'fr':'Conductivité thermique [W/mK]',
		'nl':'Thermische conductiviteit [W/mK]'
		},
	'pdf_R_bridged':{
		'en':'R with thermal bridge [m²/KW]',
		'nl':'R met koudebrug [m²/KW]',
		'fr':'R avec pont thermique [m²/KW]'
	},
	'pdf_R_unbridged':{
		'en':'Theoritical R [m²/KW]',
		'nl':'Theoretische R [m²/KW]',
		'fr':'R théorique [m²/KW]'
	},
	'pdf_withThermalBridge':{
		'en':'With thermal bridge',
		'nl':'Met koudebrug',
		'fr':'Avec pont thermique'
		},
	'pdf_withoutThermalBridge':{
		'en':'Without thermal bridge',
		'nl':'Zonder koudebrug',
		'fr':'Sans pont thermique'
		},
	'pdf_drawing_and_temperature_field':{
		'en': 'Wall composition and temperature field',
		'nl': 'Wand samenstelling en temperatuur distributie',
		'fr': 'Composition de la paroi et champ de température'
		},
	'pdf_metal_profile_characteristics':{
		'en': 'characteristics of metal profile',
		'nl': 'Eigenschappen of metaal profiel',
		'fr': 'Caractéristiques de la structure métallique'},
	'pdf_total_u_and_r':{
		'en':'Total R and U values',
		'nl':'Totaal R en U waarden',
		'fr':'Valeurs U et R totales'
	},
	'pdf_r_wall':{
		'en':'R construction',
		'fr':'R paroi',
		'nl':'R wand'},
	'pdf_r_total':{
		'en':'Total R',
		'fr':'R Total',
		'nl':'Totaal R'
		},
	'pdf_generated_on':{
	'en':'Generated on',
	'fr':'Généré le',
	'nl':'Berekend op'}
		
};


function replaceTextBasedOnLanguage(currentLang) {
  document.querySelectorAll('[lang_key]').forEach(element => {
    const key = element.getAttribute('lang_key');
    // Check if the key exists in the translations and if the key has a translation for the current language
    if (translations[key] && translations[key][currentLang]) {
      const translation = translations[key][currentLang];

	  if (element.tagName == "INPUT"){
	    element.value = translation;
	  }
	  if (element.tagName == "SELECT"){
	    element.value = translation;
	  }
	  if (element.tagName == "OPTION"){
		element.textContent = translation;
	  }
			

      element.textContent = translation;
    } else {
      // If the translation for the key doesn't exist, you can either skip or set a default text
      console.warn(`No translation found for key: '${key}' in language: '${currentLang}'. Skipping...`);
      // Optional: Set a default text if necessary
      // element.textContent = "Translation not available";
    }
  });
}


document.getElementById('languageSelect').addEventListener('change', function() {
  const selectedLang = this.value;
  replaceTextBasedOnLanguage(selectedLang);
});

// Optional: Call on page load with default language
document.addEventListener('DOMContentLoaded', function() {
  const defaultLang = navigator.language.slice(0, 2); // Or your default language
  replaceTextBasedOnLanguage(defaultLang);
});

</script>




<input type="submit" lang_key = "generate_pdf" value="Générer rapport PDF" onclick="genPDF();return null;">




<script>
addRow(eValue=1,lambdaValue=0.2,cValue='gypsum');
addRow(eValue=1,lambdaValue=0.13,cValue='wood');
addRow(eValue=5,lambdaValue=0.035,cValue='insulation',checked='checked');
addRow(eValue=30,lambdaValue=1.5,cValue='briques');



loadAllPython();
</script>

</div>

</body>
</html> 
